---
title: "2. Connect Data Source"
sidebarTitle: "2. Connect Datasource"
order: 0
---

<iframe width="560" height="315" src="https://www.youtube.com/embed/tjzjaykQqkg" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> 

Upon navigating to schema tab on API details page you’ll see a split screen view with schema and user interface for available fields to configure the datasource.

You can attach datasource to each individual field and can also re-use the datasource for multiple fields for performance benefits in case it has similar configuration (it needs to use the same upstream URL and method).

We will start with attaching datasource to user query using following approach. 

#### 1. Select field to attach datasource.
Upon selecting the `Users` field on type `Query`, you'll see the options to configure that field for following kinds of datasources.

* REST
* GraphQL
* Kafka

#### 2. Select datasource type.

Since our upstream services are REST, we'll select REST as datasource type but other kind of datasources can be used as well:

* *Use external data source*: Will allow to configure the field to resolve with the external API (outside Tyk environment)
* *Using exiting APIs*: Which will allow to configure the field with the API that already exists in Tyk environment.
* *Re-use already configured data source*: If you already have configured a data source for the same API you can re-use the same data-source. If the data source is reused the endpoint will only be called once by Tyk.

You can learn more about it [here](../../concepts/datasources/)

#### 3. Configure datasource details.

Configure the data source with the following fields

**Name**

 Enter a unique datasource name configuration to reuse it in the future. We will name this as `getUserById` for the given example.
When configuring a datasource name with Tyk Dashboard, a default name is created automatically by concatenating the field name and the GraphQL type name with an underscore symbol in between. For example, _getUserById_Query_. This name is editable and can be changed by the user.

**URL**

We will use the URL for our `Users` service which returns details of an user for given `id` i.e `http://localhost:4000/users/:id`.

To dynamically inject the `id` for every request made, we can use templating syntax and inject `id` with user supplied argument or we can also use session object.

To avoid typos in template you can use the UI component to automatically create a template for you. You can select from the available argument and object template options from the list generated by input component which is triggered by entering `{` in input.

To learn more about arguments click [here](../../concepts/arguments/)

To learn more about reusing response fields click [here](../../concepts/reusing_response_fields)

#### 4. Enter datasource name.

Enter a unique datasource name your configuration to reuse it in the future. We will name this as `getUserById` for the given example

#### 5. Select HTTP method for the URL.

You can select the HTTP method for your upstream url. Which should be `GET` in our case.

#### 6. Add headers (Optional)

If you upstream expects headers, you can supply them using this.
You can also use templating syntax here to reuse request headers.

#### 7. Select field mapping

Keep the field mapping disabled by default.
You can use field mapping to map the API response with your schema.

You can learn more about field mapping [here](../../concepts/field_mappings)

#### 8. Save data source

It is important to save the datasource configuration in order to reflect the changes in your API definition.
The` “Save & Update API” `button will persist the full API definition.

#### 9. Update API and Test

Click Update the API.

You can now query your UDG API of `user` using the Playground tab in API designer

```gql
query getUser {
  user(id:"1"){
    username
    id
    reviews {
      id
      text
      user {
        id
      }
      
    }
  }
}
```

The above query should return the response as follows 

```json
{
  "data": {
    "user": {
      "username": "John Doe",
      "id": "1",
      "reviews": null
    }
  }
}
```

#### Challenge

1. Try to resolve `reviews` field on type `Users`
2. Try to resolve `users` field on type `Reviews`

As you can see our query resolved for user details but returns `null` for `reviews`. 

This happens because we haven't defined datasource on field level for `reviews` on type `User`. 

```
Notes
- For reviews field on type User
- - Description :: get reviews by userId
- - URL :: http://localhost:4001/reviews/:userId
- - Method :: GET

- For users field on type Review
- - Description :: get user details by Id
- - URL :: http://localhost:4000/users/:userId
- - Method :: GET

- You can reuse response filed using templating syntax example `{{.object.id}}`
```


<Note>
You can find the solution for the challenge in the above video.
</Note>


<hr />

Now that we have linked datasources for our queries, let's see how we can do the same for mutations in the next section.
